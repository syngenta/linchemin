import copy
from typing import List, Union

from linchemin.cgu.convert import converter
from linchemin.cgu.syngraph import MonopartiteReacSynGraph, merge_syngraph, BipartiteSynGraph
from linchemin.cheminfo.models import ChemicalEquation, Molecule
from linchemin.rem.route_descriptors import find_path
from linchemin.utilities import console_logger

""" Module containing functions and classes to identify and extract routes """

logger = console_logger(__name__)


class NewRouteBuilder:
    """ RouteBuilder to handle the creation of new routes from a pre-existing list of routes
        and a sequence of new nodes
    """

    def search_new_routes(self,
                          original_routes: List[MonopartiteReacSynGraph],
                          branching_mol: Molecule,
                          new_graph: MonopartiteReacSynGraph) -> Union[List[MonopartiteReacSynGraph],
                                                                       None]:
        """ To start the search for new routes generated by the addition of new nodes"""
        target = {mol for route in original_routes for mol in route.get_molecule_roots()}
        if branching_mol in target:
            # if the branching molecule is the target of the original routes,
            # the new sequence of nodes is a brand-new route
            return [new_graph]

        branching_nodes = self.identify_branching_nodes(original_routes, branching_mol)
        if branching_nodes is None:
            logger.warning("None of the input routes is connected the new node. None is returned.")
            return None

        return self.build_new_routes(original_routes, branching_nodes, branching_mol, new_graph)

    def build_new_routes(self,
                         original_routes: List[MonopartiteReacSynGraph],
                         branching_nodes: dict,
                         branching_mol: Molecule,
                         new_graph: MonopartiteReacSynGraph) -> List[MonopartiteReacSynGraph]:
        """ To build the new routes """
        new_routes: List[MonopartiteReacSynGraph] = []
        new_sequence_root = new_graph.get_roots()[0]
        for r_uid, branching_node in branching_nodes.items():
            route = next(r for r in original_routes if r.uid == r_uid)
            if next((leaf for leaf in route.get_leaves() if branching_mol.uid in leaf.role_map['reactants']), None):
                # the branching node is a leaf!
                new_route = copy.deepcopy(route)
            else:
                # the branching node is an intermediate!
                new_route = self.remove_nodes_from_route(route, branching_node)

            new_route.add_node((new_sequence_root, [branching_node]))
            new_route: MonopartiteReacSynGraph = merge_syngraph([new_route, new_graph])
            new_routes = self.update_route_list(new_route, new_routes)

        return new_routes

    @staticmethod
    def identify_branching_nodes(original_routes: List[MonopartiteReacSynGraph],
                                 branching_mol: Molecule) -> Union[dict, None]:
        """ To identify the branching nodes for each of the routes in the original list
            A branching node is a reaction node that has the branching molecule as a reactant
        """
        if d := {r.uid: n_ce for r in original_routes for n_ce in r.graph if
                 branching_mol.uid in n_ce.role_map['reactants']}:
            return d
        else:
            return None

    @staticmethod
    def remove_nodes_from_route(route: MonopartiteReacSynGraph,
                                branching_node: ChemicalEquation) -> MonopartiteReacSynGraph:
        """ To build a new route from a path, i.e. a list of ChemicalEquation objects """
        new_route = copy.deepcopy(route)
        for leaf in new_route.get_leaves():
            if path := find_path(new_route, leaf, branching_node):
                [new_route.graph.pop(ce) for ce in path if ce != branching_node]
        return new_route

    @staticmethod
    def update_route_list(new_route: MonopartiteReacSynGraph,
                          route_list: List[MonopartiteReacSynGraph]) -> List[MonopartiteReacSynGraph]:
        """ To update the list of new routes """
        if new_route not in route_list:
            route_list.append(new_route)
        return route_list


def identify_branching_molecule(syngraph: MonopartiteReacSynGraph) -> Molecule:
    """ To identify the branching Molecule
        The branching molecule is identified as the product of root of the new sequence of nodes
    """
    new_sequence_root = syngraph.get_roots()[0]
    return next(m for h, m in new_sequence_root.catalog.items() if h in new_sequence_root.role_map['products'])


def build_graph_from_node_sequence(new_nodes: List[str]) -> MonopartiteReacSynGraph:
    """ To build a MonopartiteReacSynGraph from a list of reaction smiles """
    new_nodes_d = [{'query_id': n,
                    'output_string': s} for n, s in enumerate(new_nodes)]
    return MonopartiteReacSynGraph(new_nodes_d)


def route_miner(original_routes: List[Union[MonopartiteReacSynGraph,
                                            BipartiteSynGraph]],
                new_nodes: List[str]) -> Union[List[MonopartiteReacSynGraph], None]:
    """ To mine routes from a list of routes to which one or more reaction nodes are added

        :param:
            original_routes: a list of MonopartiteReacSynGraph or BipartiteSynGraph objects

            new_nodes: a list of strings representing the smiles of the new ChemicalEquations

        :return:
            the list of new routes if any, None otherwise

        :raise:
            TypeError: if the objects in the input list are not of the correct type
    """
    if all(isinstance(r, MonopartiteReacSynGraph) for r in original_routes):
        original_routes = original_routes
    elif any(isinstance(r, BipartiteSynGraph) for r in original_routes):
        original_routes = [converter(route, 'monopartite_reactions') for route in original_routes]
    else:
        logger.error("Only monopartite-reactions and bipartite syngraph objects can be used.")
        raise TypeError

    new_graph = build_graph_from_node_sequence(new_nodes)
    branching_mol = identify_branching_molecule(new_graph)

    route_builder = NewRouteBuilder()
    return route_builder.search_new_routes(original_routes,
                                           branching_mol,
                                           new_graph)
