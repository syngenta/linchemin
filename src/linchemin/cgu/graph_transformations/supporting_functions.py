from linchemin.cgu.iron import Iron, Node, Edge, Direction
from typing import Union, Tuple


def az_dict_to_iron(
    route: dict, iron: Union[Iron, None], parent: Union[str, None]
) -> Iron:
    """
    To populate an Iron instance from a nested dictionary generated by AZ CASP.

    Parameters:
    ------------
    route: dict
        The nested dictionary representing the input route
    properties: dict
        It contains the properties of the node to be stored
    iron: Union[Iron, None]
        The Iron instance that is built
    parent: int
        The id of the parent node

    Returns:
    ---------
    iron: Iron
        The output Iron instance
    """
    # During the first iteration, create Iron instance
    if not iron:
        iron = Iron()

    # if the node is a molecule node, go on and add node and edge to the Iron instance
    if route["type"] == "mol":
        iron, id_n = populate_iron(parent, route["smiles"], iron)

        # If the node has 'children' nodes, iterate over them and call iteratively this function
        if "children" in route:
            for child in route["children"]:
                az_dict_to_iron(child, iron, id_n)

    # if the node is a reaction node, ignore it and proceed with the next level
    elif "children" in route:
        for child in route["children"]:
            az_dict_to_iron(child, iron, parent)

    return iron


def mit_dict_to_iron(
    route: dict, iron: Union[Iron, None], parent: Union[str, None]
) -> Iron:
    """
    To populate an Iron instance from a nested dictionary generated by MIT CASP.

    Parameters:
    ------------
    route: dict
        The nested dictionary representing the input route
    iron: Union[Iron, None]
        The Iron instance that is built
    parent: int
        The id of the parent node

    Returns:
    ---------
    iron: Iron
        The output Iron instance
    """
    # During the first iteration, create Iron instance
    if not iron:
        iron = Iron()

    # if the node is a molecule node, go on and add node and edge to the Iron instance
    if "is_chemical" in route:
        molecules = route["smiles"].split(".")

        for mol in molecules:
            iron, id_n = populate_iron(parent, mol, iron)

            # If the node has 'children' nodes, iterate over them and call iteratively this function
            if "children" in route:
                for child in route["children"]:
                    mit_dict_to_iron(child, iron, id_n)

    # if the node is a reaction node, ignore it and proceed with the next level
    elif "children" in route:
        for child in route["children"]:
            mit_dict_to_iron(child, iron, parent)

    return iron


def ibm_dict_to_iron(
    route: dict, iron: Union[Iron, None], parent: Union[str, None]
) -> Iron:
    """
    To populate an Iron instance from a nested dictionary generated by IBM CASP.

    Parameters:
    ------------
    route: dict
        The nested dictionary representing the input route
    properties: dict
        It contains the properties of the node to be stored
    iron: Union[Iron, None]
        The Iron instance that is built
    parent: int
        The id of the parent node

    Returns:
    ---------
    iron: Iron
        The output Iron instance
    """
    # During the first iteration, create Iron instance
    if not iron:
        iron = Iron()

    if "artifact" not in route["metaData"]:
        molecules = route["smiles"].split(".")

        for mol in molecules:
            iron, id_n = populate_iron(parent, mol, iron)

            # If the node has 'children' nodes, iterate over them and call iteratively this function
            if "children" in route:
                for child in route["children"]:
                    ibm_dict_to_iron(child, iron, id_n)
    return iron


def populate_iron(parent: str, mol: str, iron: Iron) -> Tuple[Iron, str]:
    """
    To add new entities to an Iron instance

    Parameters:
    ------------
    parent: str
        The id of the parent node
    mol: str
        The smiles of the new node
    iron: Iron
        the Iron object to which the new node should be added

    Returns:
    ----------
    Tuple[Iron, str]:
        The Iron object with the new node

        The string representing the id of the new node
    """
    # Count the number of nodes already present in the Iron structure and use it as id for the node
    id_n = str(iron.i_node_number())

    # Store additional information related to the node into the Iron node properties
    prop = {"node_smiles": mol}

    # Create node and add it to the Iron structure
    node = Node(properties=prop, iid=id_n, labels=[])
    iron.add_node(str(id_n), node)
    # If the node is a "child" node, create edge from it to the parent node
    # The edge direction follows the chemical reaction direction: from reagent to product
    if parent is not None:
        id_e = str(iron.i_edge_number())
        edge = build_iron_edge(id_n, parent, id_e)
        iron.add_edge(str(id_e), edge)
    return iron, id_n


def build_iron_edge(source_node_id: str, target_node_id: str, id_e: str) -> Edge:
    """
    To build an edge object for an Iron instance from the ids of the involved nodes

    Parameters:
    ------------
    id_n1: str
        The id of the source node
    id_n2: str
        The id of the target node
    id_e: str
        The id of the output edge

    Returns:
    ---------
    an iron.Edge object
    """
    d = Direction(f"{source_node_id}>{target_node_id}")
    return Edge(
        iid=str(id_e),
        a_iid=str(source_node_id),
        b_iid=str(target_node_id),
        direction=d,
        properties={},
        labels=[],
    )
