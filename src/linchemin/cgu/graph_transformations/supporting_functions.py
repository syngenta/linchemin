from typing import Tuple, Union

from linchemin.cgu.iron import Direction, Edge, Iron, Node


def az_dict_to_iron(
    route: dict, iron: Union[Iron, None], parent: Union[str, None]
) -> Iron:
    """
    To populate an Iron instance from a nested dictionary generated by AZ CASP.

    Parameters:
    ------------
    route: dict
        The nested dictionary representing the input route
    properties: dict
        It contains the properties of the node to be stored
    iron: Union[Iron, None]
        The Iron instance that is built
    parent: int
        The id of the parent node

    Returns:
    ---------
    iron: Iron
        The output Iron instance
    """
    # During the first iteration, create Iron instance
    if not iron:
        iron = Iron()

    # if the node is a molecule node, go on and add node and edge to the Iron instance
    if route["type"] == "mol":
        iron, id_n = populate_iron(parent, route["smiles"], iron)

        # If the node has 'children' nodes, iterate over them and call iteratively this function
        if "children" in route:
            for child in route["children"]:
                az_dict_to_iron(child, iron, id_n)

    # if the node is a reaction node, ignore it and proceed with the next level
    elif "children" in route:
        for child in route["children"]:
            az_dict_to_iron(child, iron, parent)

    return iron


def mit_dict_to_iron(
    route: dict, iron: Union[Iron, None], parent: Union[str, None]
) -> Iron:
    """
    To populate an Iron instance from a nested dictionary generated by MIT CASP.

    Parameters:
    ------------
    route: dict
        The nested dictionary representing the input route
    iron: Union[Iron, None]
        The Iron instance that is built
    parent: int
        The id of the parent node

    Returns:
    ---------
    iron: Iron
        The output Iron instance
    """
    # During the first iteration, create Iron instance
    if not iron:
        iron = Iron()

    # if the node is a molecule node, go on and add node and edge to the Iron instance
    if "is_chemical" in route:
        molecules = route["smiles"].split(".")

        for mol in molecules:
            iron, id_n = populate_iron(parent, mol, iron)

            # If the node has 'children' nodes, iterate over them and call iteratively this function
            if "children" in route:
                for child in route["children"]:
                    mit_dict_to_iron(child, iron, id_n)

    # if the node is a reaction node, ignore it and proceed with the next level
    elif "children" in route:
        for child in route["children"]:
            mit_dict_to_iron(child, iron, parent)

    return iron


def ibm_dict_to_iron(
    route: dict, iron: Union[Iron, None], parent: Union[str, None]
) -> Iron:
    """
    To populate an Iron instance from a nested dictionary generated by IBM CASP.

    Parameters:
    ------------
    route: dict
        The nested dictionary representing the input route
    properties: dict
        It contains the properties of the node to be stored
    iron: Union[Iron, None]
        The Iron instance that is built
    parent: int
        The id of the parent node

    Returns:
    ---------
    iron: Iron
        The output Iron instance
    """
    # During the first iteration, create Iron instance
    if not iron:
        iron = Iron()

    if "artifact" not in route["metaData"]:
        molecules = route["smiles"].split(".")

        for mol in molecules:
            iron, id_n = populate_iron(parent, mol, iron)

            # If the node has 'children' nodes, iterate over them and call iteratively this function
            if "children" in route:
                for child in route["children"]:
                    ibm_dict_to_iron(child, iron, id_n)
    return iron


def askcosv2_dict_to_iron(route: dict) -> Iron:
    iron = Iron()
    all_nodes = route["nodes"]
    all_edges = route["edges"]
    for node in all_nodes:
        id_n = node["id"]
        smiles = node["smiles"]
        prop = {"node_smiles": smiles}
        iron_node = Node(properties=prop, iid=id_n, labels=[])
        iron.add_node(iron_node.iid, iron_node)
    for edge in all_edges:
        id_e = str(iron.i_edge_number())
        iron_edge = handle_edge(edge, id_e)
        iron.add_edge(iron_edge.iid, iron_edge)
    return iron


def handle_edge(edge: dict, id_e: str) -> Edge:
    """To build an Iron Edge from the Askcos V2 dictionary"""
    source_node_id = edge["from"]
    target_node_id = edge["to"]
    return build_iron_edge(source_node_id, target_node_id, id_e)


def handle_reaction_node(node: dict) -> Node:
    """To build a reaction Iron Node from the Askcos V2 dictionary.
    Not used for now: the reagents are reported as SMARTS rather than SMILES
    """
    id_n = node["id"]
    smiles = node["smiles"]
    reagent = node["necessary_reagent"]
    if reagent != "":
        reagent = reagent.strip("[]")
        reactants, products = smiles.split(">>")
        smiles = ">".join([reactants, reagent, products])
    prop = {"node_smiles": smiles}
    node = Node(properties=prop, iid=id_n, labels=[])
    return node


def populate_iron(parent: str, mol: str, iron: Iron) -> Tuple[Iron, str]:
    """
    To add new entities to an Iron instance

    Parameters:
    ------------
    parent: str
        The id of the parent node
    mol: str
        The smiles of the new node
    iron: Iron
        the Iron object to which the new node should be added

    Returns:
    ----------
    Tuple[Iron, str]:
        The Iron object with the new node

        The string representing the id of the new node
    """
    # Count the number of nodes already present in the Iron structure and use it as id for the node
    id_n = str(iron.i_node_number())

    # Store additional information related to the node into the Iron node properties
    prop = {"node_smiles": mol}

    # Create node and add it to the Iron structure
    node = Node(properties=prop, iid=id_n, labels=[])
    iron.add_node(id_n, node)
    # If the node is a "child" node, create edge from it to the parent node
    # The edge direction follows the chemical reaction direction: from reagent to product
    if parent is not None:
        id_e = str(iron.i_edge_number())
        edge = build_iron_edge(id_n, parent, id_e)
        iron.add_edge(str(id_e), edge)
    return iron, id_n


def build_iron_edge(source_node_id: str, target_node_id: str, id_e: str) -> Edge:
    """
    To build an edge object for an Iron instance from the ids of the involved nodes

    Parameters:
    ------------
    id_n1: str
        The id of the source node
    id_n2: str
        The id of the target node
    id_e: str
        The id of the output edge

    Returns:
    ---------
    an iron's Edge object
    """
    d = Direction(f"{source_node_id}>{target_node_id}")
    return Edge(
        iid=id_e,
        a_iid=source_node_id,
        b_iid=target_node_id,
        direction=d,
        properties={},
        labels=[],
    )
