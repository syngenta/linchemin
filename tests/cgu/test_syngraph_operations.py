import json
import unittest

import pytest

from linchemin.cgu.syngraph import BipartiteSynGraph, MonopartiteReacSynGraph
from linchemin.cgu.syngraph_operations import (
    add_reaction_to_syngraph,
    extract_reactions_from_syngraph,
    find_all_paths,
    find_path,
    merge_syngraph,
    remove_reaction_from_syngraph,
)
from linchemin.cgu.translate import translator
from linchemin.cheminfo.constructors import ChemicalEquationConstructor

test_route = [
    {
        "output_string": "BrB(Br)Br.COc1cc(OC)c2c(=O)cc(-c3ccccc3Cl)oc2c1I.ClCCl>>O=c1cc(-c2ccccc2Cl)oc2c(I)c(O)cc(O)c12",
        "query_id": 0,
    },
    {
        "output_string": "C1CCOC1.CN1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1.CO>>CN1CCC(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1",
        "query_id": 1,
    },
    {
        "output_string": "C1COCCO1.CC(C)(C)OC(=O)N1CC=C(B2OC(C)(C)C(C)(C)O2)C(O)C1.Cl[Pd]Cl.O.O=c1cc(-c2ccccc2Cl)oc2c(I)c(O)cc(O)c12.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[Cs+].[F-].[Fe]>>CC(C)(C)OC(=O)N1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1",
        "query_id": 2,
    },
    {
        "output_string": "C=O.CC(=O)O.CO.O=c1cc(-c2ccccc2Cl)oc2c(C3=CCNCC3O)c(O)cc(O)c12.[BH3-]C#N.[Na+]>>CN1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1",
        "query_id": 3,
    },
    {
        "output_string": "CC#N.CC(C)(C)OC(=O)N1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1.C[Si](C)(C)Cl.[I-].[Na+]>>O=c1cc(-c2ccccc2Cl)oc2c(C3=CCNCC3O)c(O)cc(O)c12",
        "query_id": 4,
    },
    {
        "output_string": "CC(=O)[O-].CC(C)(C)OC(=O)N1CC=C(OS(=O)(=O)C(F)(F)F)C(O)C1.CC1(C)OB(B2OC(C)(C)C(C)(C)O2)OC1(C)C.COCCOC.ClCCl.Cl[Pd]Cl.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[Fe].[K+]>>CC(C)(C)OC(=O)N1CC=C(B2OC(C)(C)C(C)(C)O2)C(O)C1",
        "query_id": 5,
    },
]


def test_syngraph_merging(ibm1_path, az_path):
    """To test that a list of Syngraph/MonopartiteSynGraph objects is correctly merged."""
    graph_ibm = json.loads(open(ibm1_path).read())
    all_routes_ibm = [
        translator("ibm_retro", g, "syngraph", out_data_model="bipartite")
        for g in graph_ibm
    ]

    graph_az = json.loads(open(az_path).read())
    all_routes_az = [
        translator("az_retro", g, "syngraph", out_data_model="bipartite")
        for g in graph_az
    ]

    synroutes = list(all_routes_ibm)
    synroutes.extend(iter(all_routes_az))
    # SynGraph instances generated by different CASPs can be merged
    merged = merge_syngraph(synroutes)
    assert isinstance(merged, BipartiteSynGraph)

    roots = merged.get_roots()
    roots_smiles = [mol.smiles for mol in roots]
    assert roots_smiles == [
        "CCNC(=O)CC",
        "Cc1cccc(C)c1N(CC(=O)Nc1ccc(-c2ncon2)cc1)C(=O)C1CCS(=O)(=O)CC1",
    ]
    leaves = merged.get_leaves()
    assert [mol.smiles for mol in leaves] == [
        "CCN",
        "CCOC(=O)CC",
        "CCO",
        "C1CCOC1",
        "CCC(=O)Cl",
        "ClCCl",
        "O",
        "CCOC(C)=O",
        "CCC(=O)O",
        "CCC(=O)OC(=O)CC",
        "O=C(O)C1CCS(=O)(=O)CC1",
        "Nc1ccc(-c2ncon2)cc1",
        "Cc1cccc(C)c1NCC(=O)O",
        "CCOC(=O)CNc1c(C)cccc1C",
        "O=C(Cl)C1CCS(=O)(=O)CC1",
        "Cc1cccc(C)c1N",
        "O=C(Br)CBr",
    ]

    # MonopartiteSynGraph instances can be merged
    mp_syngraphs = [
        translator("az_retro", g, "syngraph", out_data_model="monopartite_reactions")
        for g in graph_az
    ]

    merged_mp_syngraph = merge_syngraph(mp_syngraphs)
    assert (
        isinstance(merged_mp_syngraph, MonopartiteReacSynGraph)
        and len(merged_mp_syngraph.graph) == 11
    )

    # An error is raised if the input routes are in the wrong format
    with pytest.raises(TypeError) as te:
        all_routes = [
            translator("ibm_retro", g, "networkx", out_data_model="bipartite")
            for g in graph_ibm
        ]
        merge_syngraph(all_routes)
    assert "TypeError" in str(te.type)

    all_routes_ibm.extend(mp_syngraphs)
    # An error is raised if the input routes have mixed formats
    with pytest.raises(TypeError) as te:
        merge_syngraph(all_routes_ibm)
    assert "TypeError" in str(te.type)


def test_extract_reactions(az_path):
    graph_az = json.loads(open(az_path).read())
    syngraph = translator("az_retro", graph_az[0], "syngraph", "monopartite_reactions")
    reactions = extract_reactions_from_syngraph(syngraph)
    assert len(reactions) == 2
    assert (
        "Cc1cccc(C)c1NCC(=O)O.Nc1ccc(-c2ncon2)cc1>>Cc1cccc(C)c1NCC(=O)Nc1ccc("
        "-c2ncon2)cc1" in [reaction["input_string"] for reaction in reactions]
    )

    syngraph = translator(
        "az_retro", graph_az[0], "syngraph", out_data_model="bipartite"
    )
    reactions2 = extract_reactions_from_syngraph(syngraph)
    assert reactions == reactions2

    mpm_syngraph = translator(
        "az_retro", graph_az[0], "syngraph", out_data_model="monopartite_molecules"
    )
    reactions3 = extract_reactions_from_syngraph(mpm_syngraph)
    assert reactions3 == reactions2

    with pytest.raises(TypeError) as te:
        extract_reactions_from_syngraph(["list"])
    assert "TypeError" in str(te.type)


def test_find_path(ibm1_path):
    """To test that find_path function returns the expected path."""
    graph = json.loads(open(ibm1_path).read())
    syngraph = translator("ibm_retro", graph[0], "syngraph", out_data_model="bipartite")
    root = syngraph.get_roots()
    leaves = syngraph.get_leaves()
    path = find_path(syngraph, leaves[0], root[0])
    assert [item.smiles for item in path] == [
        "CCN",
        "CCN.CCOC(=O)CC>>CCNC(=O)CC",
        "CCNC(=O)CC",
    ]


def test_all_paths(az_path):
    graph = json.loads(open(az_path).read())
    syngraph = translator("az_retro", graph[2], "syngraph", out_data_model="bipartite")
    all_paths = find_all_paths(syngraph)
    assert len(all_paths) == 3


def test_remove_nodes_from_syngraph():
    syngraph = MonopartiteReacSynGraph(test_route)
    node_to_remove = "CC#N.CC(C)(C)OC(=O)N1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1.C[Si](C)(C)Cl.[I-].[Na+]>>O=c1cc(-c2ccccc2Cl)oc2c(C3=CCNCC3O)c(O)cc(O)c12"
    # with removal of dangling nodes
    new_syngraph = remove_reaction_from_syngraph(
        syngraph, node_to_remove, remove_dandling_nodes=True
    )
    assert len(new_syngraph.graph) == 2
    assert len(new_syngraph.graph) != len(syngraph.graph)
    assert len(new_syngraph.get_roots()) == 1
    assert isinstance(new_syngraph, MonopartiteReacSynGraph)
    # keeping the dandling nodes
    new_syngraph = remove_reaction_from_syngraph(
        syngraph, node_to_remove, remove_dandling_nodes=False
    )
    assert len(new_syngraph.graph) == 5 and len(new_syngraph.graph) < len(
        syngraph.graph
    )
    assert len(new_syngraph.get_roots()) > 1
    # an error is raised if the input graph is in th wrong format
    with pytest.raises(TypeError) as te:
        remove_reaction_from_syngraph(test_route, node_to_remove)
    assert "TypeError" in str(te.type)

    syngraph_bp = BipartiteSynGraph(test_route)
    # if the selected node is not present in the input graph, the latter is returned unchanged
    with unittest.TestCase().assertLogs(
        "linchemin.cgu.syngraph_operations", level="WARNING"
    ) as cm:
        wrong_node_to_remove = "CCN.O>>CCO"
        new_graph = remove_reaction_from_syngraph(syngraph_bp, wrong_node_to_remove)
    assert new_graph == syngraph_bp
    unittest.TestCase().assertEqual(len(cm.records), 1)
    unittest.TestCase().assertIn(
        "The selected node is not present in the input graph",
        cm.records[0].getMessage(),
    )
    new_bp = remove_reaction_from_syngraph(syngraph_bp, node_to_remove)
    assert len(new_bp.graph) != len(syngraph_bp.graph)
    assert len(new_bp.graph) == 10
    with pytest.raises(TypeError) as te:
        remove_reaction_from_syngraph(syngraph_bp, "COc1cc(OC)c2c(occc2=O)c1I")
    assert "SmilesTypeError" in str(te.type)


def test_add_reaction_to_syngraph():
    syngraph = BipartiteSynGraph(test_route)
    reaction_smiles = (
        "COc1cc(OC)c2c(occc2=O)c1I.Clc1ccccc1>>COc1cc(OC)c2c(oc(cc2=O)-c2ccccc2Cl)c1I"
    )
    new_graph = add_reaction_to_syngraph(syngraph, reaction_smiles)
    assert isinstance(new_graph, type(syngraph))
    ce = ChemicalEquationConstructor().build_from_reaction_string(
        reaction_smiles, "smiles"
    )
    assert ce in new_graph.graph
    with pytest.raises(TypeError) as te:
        add_reaction_to_syngraph(test_route, reaction_smiles)
    assert "TypeError" in str(te.type)
    with pytest.raises(TypeError) as te:
        add_reaction_to_syngraph(syngraph, "COc1cc(OC)c2c(occc2=O)c1I")
    assert "SmilesTypeError" in str(te.type)
