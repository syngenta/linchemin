from linchemin.cgu.syngraph_operations import (
    merge_syngraph,
    extract_reactions_from_syngraph,
    find_path,
    remove_nodes_from_syngraph,
)
import json
import pytest
from linchemin.cgu.translate import translator
from linchemin.cgu.syngraph import (
    BipartiteSynGraph,
    MonopartiteMolSynGraph,
    MonopartiteReacSynGraph,
)

import unittest


def test_syngraph_merging(ibm1_path, az_path):
    """To test that a list of Syngraph/MonopartiteSynGraph objects is correctly merged."""
    graph_ibm = json.loads(open(ibm1_path).read())
    all_routes_ibm = [
        translator("ibm_retro", g, "syngraph", out_data_model="bipartite")
        for g in graph_ibm
    ]

    graph_az = json.loads(open(az_path).read())
    all_routes_az = [
        translator("az_retro", g, "syngraph", out_data_model="bipartite")
        for g in graph_az
    ]

    synroutes = list(all_routes_ibm)
    synroutes.extend(iter(all_routes_az))
    # SynGraph instances generated by different CASPs can be merged
    merged = merge_syngraph(synroutes)
    assert type(merged) == BipartiteSynGraph

    roots = merged.get_roots()
    roots_smiles = [mol.smiles for mol in roots]
    assert roots_smiles == [
        "CCNC(=O)CC",
        "Cc1cccc(C)c1N(CC(=O)Nc1ccc(-c2ncon2)cc1)C(=O)C1CCS(=O)(=O)CC1",
    ]
    leaves = merged.get_leaves()
    assert [mol.smiles for mol in leaves] == [
        "CCN",
        "CCOC(=O)CC",
        "CCO",
        "C1CCOC1",
        "CCC(=O)Cl",
        "ClCCl",
        "O",
        "CCOC(C)=O",
        "CCC(=O)O",
        "CCC(=O)OC(=O)CC",
        "O=C(O)C1CCS(=O)(=O)CC1",
        "Nc1ccc(-c2ncon2)cc1",
        "Cc1cccc(C)c1NCC(=O)O",
        "CCOC(=O)CNc1c(C)cccc1C",
        "O=C(Cl)C1CCS(=O)(=O)CC1",
        "Cc1cccc(C)c1N",
        "O=C(Br)CBr",
    ]

    # MonopartiteSynGraph instances can be merged
    mp_syngraphs = [
        translator("az_retro", g, "syngraph", out_data_model="monopartite_reactions")
        for g in graph_az
    ]

    merged_mp_syngraph = merge_syngraph(mp_syngraphs)
    assert (
        type(merged_mp_syngraph) == MonopartiteReacSynGraph
        and len(merged_mp_syngraph.graph) == 11
    )

    # An error is raised if the input routes are in the wrong format
    with pytest.raises(TypeError) as te:
        all_routes = [
            translator("ibm_retro", g, "networkx", out_data_model="bipartite")
            for g in graph_ibm
        ]
        merge_syngraph(all_routes)
    assert "TypeError" in str(te.type)

    mixed_type = all_routes_ibm.extend(iter(mp_syngraphs))
    # An error is raised if the input routes have mixed formats
    with pytest.raises(TypeError) as te:
        merge_syngraph(mixed_type)
    assert "TypeError" in str(te.type)


def test_extract_reactions(az_path):
    graph_az = json.loads(open(az_path).read())
    syngraph = translator("az_retro", graph_az[0], "syngraph", "monopartite_reactions")
    reactions = extract_reactions_from_syngraph(syngraph)
    assert len(reactions) == 2
    assert (
        reactions[1]["input_string"]
        == "Cc1cccc(C)c1NCC(=O)O.Nc1ccc(-c2ncon2)cc1>>Cc1cccc(C)c1NCC(=O)Nc1ccc("
        "-c2ncon2)cc1"
    )

    syngraph = translator(
        "az_retro", graph_az[0], "syngraph", out_data_model="bipartite"
    )
    reactions2 = extract_reactions_from_syngraph(syngraph)
    assert reactions == reactions2

    mpm_syngraph = translator(
        "az_retro", graph_az[0], "syngraph", out_data_model="monopartite_molecules"
    )
    reactions3 = extract_reactions_from_syngraph(mpm_syngraph)
    assert reactions3 == reactions2

    with pytest.raises(TypeError) as te:
        extract_reactions_from_syngraph(["list"])
    assert "TypeError" in str(te.type)


def test_find_path(ibm1_path):
    """To test that find_path function returns the expected path."""
    graph = json.loads(open(ibm1_path).read())
    syngraph = translator("ibm_retro", graph[0], "syngraph", out_data_model="bipartite")
    root = syngraph.get_roots()
    leaves = syngraph.get_leaves()
    path = find_path(syngraph, leaves[0], root[0])
    assert [item.smiles for item in path] == [
        "CCN",
        "CCN.CCOC(=O)CC>>CCNC(=O)CC",
        "CCNC(=O)CC",
    ]


def test_remove_nodes_from_syngraph():
    route = [
        {
            "output_string": "BrB(Br)Br.COc1cc(OC)c2c(=O)cc(-c3ccccc3Cl)oc2c1I.ClCCl>>O=c1cc(-c2ccccc2Cl)oc2c(I)c(O)cc(O)c12",
            "query_id": 0,
        },
        {
            "output_string": "C1CCOC1.CN1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1.CO>>CN1CCC(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1",
            "query_id": 1,
        },
        {
            "output_string": "C1COCCO1.CC(C)(C)OC(=O)N1CC=C(B2OC(C)(C)C(C)(C)O2)C(O)C1.Cl[Pd]Cl.O.O=c1cc(-c2ccccc2Cl)oc2c(I)c(O)cc(O)c12.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[Cs+].[F-].[Fe]>>CC(C)(C)OC(=O)N1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1",
            "query_id": 2,
        },
        {
            "output_string": "C=O.CC(=O)O.CO.O=c1cc(-c2ccccc2Cl)oc2c(C3=CCNCC3O)c(O)cc(O)c12.[BH3-]C#N.[Na+]>>CN1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1",
            "query_id": 3,
        },
        {
            "output_string": "CC#N.CC(C)(C)OC(=O)N1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1.C[Si](C)(C)Cl.[I-].[Na+]>>O=c1cc(-c2ccccc2Cl)oc2c(C3=CCNCC3O)c(O)cc(O)c12",
            "query_id": 4,
        },
        {
            "output_string": "CC(=O)[O-].CC(C)(C)OC(=O)N1CC=C(OS(=O)(=O)C(F)(F)F)C(O)C1.CC1(C)OB(B2OC(C)(C)C(C)(C)O2)OC1(C)C.COCCOC.ClCCl.Cl[Pd]Cl.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[CH]1[CH][CH]C(P(c2ccccc2)c2ccccc2)[CH]1.[Fe].[K+]>>CC(C)(C)OC(=O)N1CC=C(B2OC(C)(C)C(C)(C)O2)C(O)C1",
            "query_id": 5,
        },
    ]
    syngraph = MonopartiteReacSynGraph(route)
    node_to_remove = "CC#N.CC(C)(C)OC(=O)N1CC=C(c2c(O)cc(O)c3c(=O)cc(-c4ccccc4Cl)oc23)C(O)C1.C[Si](C)(C)Cl.[I-].[Na+]>>O=c1cc(-c2ccccc2Cl)oc2c(C3=CCNCC3O)c(O)cc(O)c12"

    new_syngraph = remove_nodes_from_syngraph(syngraph, node_to_remove)
    assert len(new_syngraph.graph) == 2
    assert len(new_syngraph.graph) != len(syngraph.graph)
    assert isinstance(new_syngraph, MonopartiteReacSynGraph)

    # an error is raised if the input graph is in th wrong format
    with pytest.raises(TypeError) as te:
        remove_nodes_from_syngraph(route, node_to_remove)
    assert "TypeError" in str(te.type)

    syngraph_bp = BipartiteSynGraph(route)
    # if the selected node is not present in the input graph, the latter is returned unchanged
    with unittest.TestCase().assertLogs(
        "linchemin.cgu.syngraph_operations", level="WARNING"
    ) as cm:
        node_to_remove = "CCN"
        new_graph = remove_nodes_from_syngraph(syngraph_bp, node_to_remove)
    assert new_graph == syngraph_bp
    unittest.TestCase().assertEqual(len(cm.records), 1)
    unittest.TestCase().assertIn(
        "The selected node is not present in the input graph",
        cm.records[0].getMessage(),
    )

    node_to_remove = "O=c1cc(-c2ccccc2Cl)oc2c(I)c(O)cc(O)c12"
    new_bp = remove_nodes_from_syngraph(syngraph_bp, node_to_remove)
    assert len(new_bp.graph) == 31
